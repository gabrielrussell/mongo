#!/usr/bin/perl
use warnings;
use Data::Dumper;
my $log_id = 20100;
my $any_conversions = 0;
my $all_log_lines = 0;
my $severities = {};
sub convert {
    my $ramlogs = { 'startupWarningsLog' => 'kStartupWarnings', 'rsLog' => 'kRS', 'warnings' => 'kWarnings'};
    my $expression = shift(@_);
    my $argument = shift(@_);
    my $macro = shift(@_);
    $severities->{$macro}++;
    return "$expression;" if ($expression =~ /str::stream\(\)/);

    $any_conversions = 1;

    my $message = "";
    my @options;
    my @params;

    push (@params,$log_id++);
    $all_log_lines++;

    #my $assert_value;
    #if ($macro && $macro eq "FATAL") {
    #    my $post = $';
    #    $post =~ m/(.*?);/ms;
    #    my $first = $1;
    #    if ($first =~ m/assert.*\((\d+)/) {
    #        push(@params,$1);
    #    } elsif ($first =~ m/(exit|terminate)/i) {
    #        push(@params,0);
    #    } else {
    #        $macro = 'ERROR';
    #    }
    #}

    my @parts = split(m/\s*\<\<\s*/s,$1 );
    shift @parts;
    #print "$fn -> $2 -> $1 -> @parts\n";
    my $attributes = [];

    # handle the magical Tee logstreamBuilder modifiers
    if ($ramlogs->{$parts[-1]}) {
        my $tag = $ramlogs->{$parts[-1]};
        my $rl = pop(@parts);
        push(@options, "logv2::LogTag::$tag");
    }

    # just toss out a terminal endl
    if (@parts && $parts[-1] =~ /\bendl$/) {
        pop(@parts);
    }

    # categorize logged things
    foreach my $part (@parts) {
        if ($part =~ /\bboolalpha$/) {
            next;
        } elsif ($part =~ /\bstd::dec$/) {
            #TODO, do we need to actually effect the formatting based on this formatting specifier?
            next;
        } elsif ($part =~ /\bendl$/) {
            $message .= "\\n";
        } elsif ($part =~ /^\s*'(.)'\s*$/s) {
            $message .= $1;
        } elsif ($part =~ /^\s*"(.*)"\s*$/s) {
            my $quoted_piece = $1;
            $quoted_piece =~ s[\{][{{]g;
            $quoted_piece =~ s[\}][}}]g;
            $message .= $quoted_piece;
        } else {
            $attr_name = $part;
            $attr_name =~ s[^(\W|_)+][]g;
            $attr_name =~ s[(\W+|_)$][]g;
            $attr_name =~ s[(\W|_)+][_]g;
            push(@$attributes, [ $attr_name, $part ]);
            $message .= "{}";
        }
    }
    my $output = "LOGV2";
    if ($macro ne "") {
        $output .= "_";
        $output .= $macro;
    }

    if ($argument) {
        if ($argument =~ /component/i) {
            push(@options, "logComponentV1toV2($argument)");
        } else {
            $output .= "_DEBUG";
            $severities->{$argument}++;
            if ($argument =~ /^\d+$/) {
                push(@params, $argument);
            } else {
                #push(@params, "::mongo::logger::LogSeverity($argument).toInt()");
                push(@params, "logSeverityV1toV2($argument).toInt()");
            }
        }
    }
    if (@options) {
        push(@params, "{".join(",",@options)."}");
        $output .= "_OPTIONS";
    }
    push(@params,"\"$message\"");
    foreach (@$attributes) {
        my ($attr_name, $part) = @$_;
        push(@params, "\"$attr_name\"_attr = $part");
    }
    $output .= "(" . join(", ",@params) . ");";
    return $output;
}

sub insert_include {
    my $includes = shift(@_);
    my $inc = "#include \"mongo/logv2/log.h\"";
    my $log_h_inc = "#include \"mongo/util/log.h\"";

    if (index($includes, $inc) != -1) {
        return $includes;
    }
    if (index($includes, $log_h_inc) != -1) {
        $includes =~ s[($log_h_inc)][$log_h_inc\n$inc];
        return $includes;
    }
    my @out_includes;
    my @includes = split("\n",$includes);
    my $i = scalar(@includes) -1;
    while ($i > 0 && $includes[$i] gt $inc) { $i -- }
    if ($includes[$i] eq $inc) { return join("\n",@includes) }
    return join("\n",@includes[0..$i],$inc,@includes[$i+1..$#includes])."\n";
}

foreach my $fn (@ARGV) {
    $any_conversions = 0;
    next if $fn =~ /^#/; # skip commented out file names
    warn $fn;
    open($f, "<", $fn);
    my $data = join('',<$f>);
    $data =~ s[((?<!unitte.t::)\blog\(([^\)]*)\)\s+<<[^;]*);$][convert($1,$2,'')]smige;
    $data =~ s[(\bwarning\(([^\)]*)\)\s+<<[^;]*);$][convert($1,$2,'WARNING')]smige;
    $data =~ s[(\berror\(([^\)]*)\)\s+<<[^;]*);$][convert($1,$2,'ERROR')]smige;
    $data =~ s[(\bsevere\(([^\)]*)\)\s+<<[^;]*);$][convert($1,$2,'FATAL',$3)]smige;
    next unless $any_conversions;
    $data =~ s[(#include[^\n]+\n(?:\s*\n|^#[^\n]+\n)*#include[^\n]+\n)][insert_include($1)]sem;
    open($f, ">", $fn);
    $f->print($data);
}

$severities->{"all"} = $all_log_lines;
print Dumper(\$severities);
